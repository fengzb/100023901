# SUMMARY

* [README](README.md)
* [开篇词-你为什么需要学习并发编程？](942dd10885704ec2830b1bc5b1434a8a.md)
* [01-可见性、原子性和有序性问题并发编程Bug的源头](94c8d484797549208a24d94ccde19018.md)
* [02-Java内存模型看Java如何解决可见性和有序性问题](64b960828a574263b8e1f8d80a6db22f.md)
* [03-互斥锁（上）解决原子性问题](79fd19e7f4904000ab8937d81fe8e893.md)
* [04-互斥锁（下）如何用一把锁保护多个资源？](0e02dbbc0ad8442399a6f59df391c89d.md)
* [05-一不小心就死锁了，怎么办？](9790c910b428434cab73e5ff4a5adabd.md)
* [06-用“等待-通知”机制优化循环等待](a832567ff0094b5d9d4fffc0d00f3453.md)
* [07-安全性、活跃性以及性能问题](2a9830fc9b5e46fa882faedd4dcfae04.md)
* [08-管程并发编程的万能钥匙](383cd2f6ab35402fa2da26cae92a8ba0.md)
* [09-Java线程（上）Java线程的生命周期](05ff93e0e37f4fda8fc94dd39805df0e.md)
* [10-Java线程（中）创建多少线程才是合适的？](58a3abbbba654add817ce94e65e40bf7.md)
* [11-Java线程（下）为什么局部变量是线程安全的？](f7e10633e9c74681893862d5ad7619a5.md)
* [12-如何用面向对象思想写好并发程序？](f9ea5bb4659a47a0a01f6e9e657baa05.md)
* [13-理论基础模块热点问题答疑](9e20eff4d7d64d1eb5d2e2ad808a6aab.md)
* [14-Lock和Condition（上）隐藏在并发包中的管程](d87d53bec2084a16b3395041befe8c94.md)
* [15-Lock和Condition（下）Dubbo如何用管程实现异步转同步？](009e3ff4c8594f3396f8ebbf15da6ae2.md)
* [16-Semaphore如何快速实现一个限流器？](e2620c0e8aa7471297901f41dcb2499d.md)
* [17-ReadWriteLock如何快速实现一个完备的缓存？](21bfeb34c60f4320b1abf7b96ca3c8ab.md)
* [18-StampedLock有没有比读写锁更快的锁？](7f596154a0f44c269e5e8c3ab0787822.md)
* [19-CountDownLatch和CyclicBarrier如何让多线程步调一致？](e38b65ea4a824f3794935248bb2a48e4.md)
* [20-并发容器都有哪些“坑”需要我们填？](b7e8f68899af4654be34cfdff9701e9f.md)
* [21-原子类无锁工具类的典范](e837f3b6b8b44eb486cbbf3d2886e3ef.md)
* [22-Executor与线程池如何创建正确的线程池？](13cdfc1f9a8b4c738043117f71c178e1.md)
* [23-Future如何用多线程实现最优的“烧水泡茶”程序？](64749587e78942878a0b5926d586ebba.md)
* [24-CompletableFuture异步编程没那么难](e401d89b43b240a68ae50e94ae02ac87.md)
* [25-CompletionService如何批量执行异步任务？](e1fc86fb34094a9081590a1f8e7a4020.md)
* [26-ForkJoin单机版的MapReduce](f49b73c3be724faab0b6e8acfad28cb4.md)
* [27-并发工具类模块热点问题答疑](229c93544cc44826ba3cc17748f54498.md)
* [28-Immutability模式如何利用不变性解决并发问题？](5363cbef0f7b4ce59e964435c0c569b4.md)
* [29-Copy-on-Write模式不是延时策略的COW](0455a0e8596c43bf98fb93437bcb3d89.md)
* [30-线程本地存储模式没有共享，就没有伤害](d36e1b27be15446987d521c9bf79532e.md)
* [31-GuardedSuspension模式等待唤醒机制的规范实现](977b5dcd85cd45f99e85f9ef9fd33355.md)
* [32-Balking模式再谈线程安全的单例模式](4fd3e22ffa254f57a0c8bb0155381839.md)
* [33-Thread-Per-Message模式最简单实用的分工方法](40159f3d4bd8418aa5d16154c626aa85.md)
* [34-WorkerThread模式如何避免重复创建线程？](f7e6e3e35969414c9bd46d8c5c816cfc.md)
* [35-两阶段终止模式如何优雅地终止线程？](666d78a4d57348c9bedad8c558bdbdfd.md)
* [36-生产者-消费者模式用流水线思想提高效率](9f9030d507064bc3b9c94deb48bafc3a.md)
* [37-设计模式模块热点问题答疑](1caf77be0ba44a37ac81d017df9de22b.md)
* [38-案例分析（一）高性能限流器GuavaRateLimiter](c67c9a8911214d32aeedc02c8ddfac5d.md)
* [39-案例分析（二）高性能网络应用框架Netty](9587af8753bd48eeb8bd4377ec72150d.md)
* [3个用户来信-打开一个新的并发世界](572b8bc2ba38424cbb02f25232a0e282.md)
* [40-案例分析（三）高性能队列Disruptor](ed4f1f6edda941138d0aebe3245c5641.md)
* [41-案例分析（四）高性能数据库连接池HiKariCP](cb5ea61df8704b3d9310aecc7c909c59.md)
* [42-Actor模型面向对象原生的并发模型](46628cf5f8de4ca3a9efcfa9ee2ba502.md)
* [43-软件事务内存借鉴数据库的并发经验](a6544631a4a54360acf4d6d24f89860d.md)
* [44-协程更轻量级的线程](fea7cfa5621d4725b9aca285f6694d03.md)
* [45-CSP模型Golang的主力队员](0d4f04c9158e4d2096ada965c0892724.md)
* [学习攻略-如何才能学好并发编程？](de57a73f083647faa009968649d9a3a6.md)
* [用户来信-真好，面试考到这些并发编程，我都答对了！](6ceafee912bd4ed0910e2df823af8f46.md)
* [结束语-十年之后，初心依旧](2c07291f48234fe6b0a83c1fa1a6acc9.md)
* [结课测试-这些Java并发编程实战的知识你都掌握了吗？](9fefe04039d14eadb48c33504107463f.md)
